{"version":3,"sources":["index.test.ts"],"names":["describe","size","positive","negative","params","currentIndex","_direction","direction","previousLength","currentLength","handlerOffset","it","expect","toBe"],"mappings":"kKAAA,gFAEAA,QAAQ,CAAC,yBAAD,CAA4B,UAAM,CACxC,GAAMC,CAAAA,IAAI,CAAG,GAAb,CACA,GAAMC,CAAAA,QAAQ,CAAG,CAAC,CAAlB,CACA,GAAMC,CAAAA,QAAQ,CAAG,CAAjB,CAEA,GAAMC,CAAAA,MAAM,CAAG,gBAACA,OAAD,CAKT,CACJ,GAAQC,CAAAA,YAAR,CAA+ED,OAA/E,CAAQC,YAAR,CAAiCC,UAAjC,CAA+EF,OAA/E,CAAsBG,SAAtB,CAA6CC,cAA7C,CAA+EJ,OAA/E,CAA6CI,cAA7C,CAA6DC,aAA7D,CAA+EL,OAA/E,CAA6DK,aAA7D,CACA,GAAMF,CAAAA,SAAS,CAAGD,UAAU,GAAK,UAAf,CAA4BH,QAA5B,CAAuCD,QAAzD,CACA,MAAO,CACLK,SAAS,CAATA,SADK,CAELG,aAAa,CAAET,IAAI,CAAGI,YAAP,CAAsBE,SAFhC,CAGLN,IAAI,CAAJA,IAHK,CAILO,cAAc,CAAdA,cAJK,CAKLC,aAAa,CAAbA,aALK,CAAP,CAOD,CAfD,CAiBAE,EAAE,CAAC,qGAAD,CAAwG,oKAClGN,YADkG,CACnF,CADmF,CAElGK,aAFkG,CAElF,mEAA+BN,MAAM,CAAC,CAC1DC,YAAY,CAAZA,YAD0D,CAE1DE,SAAS,CAAE,UAF+C,CAG1DC,cAAc,CAAE,CAH0C,CAI1DC,aAAa,CAAE,CAJ2C,CAAD,CAArC,CAFkF,CASxGG,MAAM,CAACF,aAAa,CAAGT,IAAjB,CAAN,CAA6BY,IAA7B,CAAkC,EAAIX,QAAtC,EATwG,qEAAxG,CAAF,CAYAS,EAAE,CAAC,iGAAD,CAAoG,4JAC9FD,aAD8F,CAC9E,mEAA+BN,MAAM,CAAC,CAC1DC,YAAY,CAAE,CAD4C,CAE1DE,SAAS,CAAE,UAF+C,CAG1DC,cAAc,CAAE,CAH0C,CAI1DC,aAAa,CAAE,CAJ2C,CAAD,CAArC,CAD8E,CAQpGG,MAAM,CAACF,aAAa,CAAGT,IAAjB,CAAN,CAA6BY,IAA7B,CAAkC,EAAIV,QAAtC,EARoG,sEAApG,CAAF,CAWAQ,EAAE,CAAC,iGAAD,CAAoG,4JAC9FD,aAD8F,CAC9E,mEAA+BN,MAAM,CAAC,CAC1DC,YAAY,CAAE,CAD4C,CAE1DE,SAAS,CAAE,UAF+C,CAG1DC,cAAc,CAAE,CAH0C,CAI1DC,aAAa,CAAE,CAJ2C,CAAD,CAArC,CAD8E,CAQpGG,MAAM,CAACF,aAAa,CAAGT,IAAjB,CAAN,CAA6BY,IAA7B,CAAkC,EAAIX,QAAtC,EARoG,sEAApG,CAAF,CAWAS,EAAE,CAAC,iGAAD,CAAoG,4JAC9FD,aAD8F,CAC9E,mEAA+BN,MAAM,CAAC,CAC1DC,YAAY,CAAE,CAD4C,CAE1DE,SAAS,CAAE,UAF+C,CAG1DC,cAAc,CAAE,CAH0C,CAI1DC,aAAa,CAAE,CAJ2C,CAAD,CAArC,CAD8E,CAQpGG,MAAM,CAACF,aAAa,CAAGT,IAAjB,CAAN,CAA6BY,IAA7B,CAAkC,EAAIV,QAAtC,EARoG,sEAApG,CAAF,CAWAQ,EAAE,CAAC,sEAAD,CAAyE,4JACnED,aADmE,CACnD,mEAA+BN,MAAM,CAAC,CAC1DC,YAAY,CAAE,CAD4C,CAE1DE,SAAS,CAAE,UAF+C,CAG1DC,cAAc,CAAE,CAH0C,CAI1DC,aAAa,CAAE,CAJ2C,CAAD,CAArC,CADmD,CAQzEG,MAAM,CAACF,aAAa,CAAGT,IAAjB,CAAN,CAA6BY,IAA7B,CAAkC,EAAIX,QAAtC,EARyE,sEAAzE,CAAF,CAUD,CA7EO,CAAR","sourcesContent":["import { computeNewIndexWhenDataChanges } from \"./computeNewIndexWhenDataChanges\";\n\ndescribe(\"should work as expected\", () => {\n  const size = 375;\n  const positive = -1;\n  const negative = 1;\n\n  const params = (params: {\n    direction: \"positive\" | \"negative\"\n    currentIndex: number\n    previousLength: number\n    currentLength: number\n  }) => {\n    const { currentIndex, direction: _direction, previousLength, currentLength } = params;\n    const direction = _direction === \"negative\" ? negative : positive;\n    return {\n      direction,\n      handlerOffset: size * currentIndex * direction,\n      size,\n      previousLength,\n      currentLength,\n    };\n  };\n\n  it(\"The direction is negative, And changing length of data set from 4 to 3, the new index will to be 2.\", async () => {\n    const currentIndex = 1;\n    const handlerOffset = computeNewIndexWhenDataChanges(params({\n      currentIndex,\n      direction: \"negative\",\n      previousLength: 4,\n      currentLength: 3,\n    }));\n\n    expect(handlerOffset / size).toBe(2 * positive);\n  });\n\n  it(\"The direction is negative, Changing length of data set from 4 to 3, the index remains original.\", async () => {\n    const handlerOffset = computeNewIndexWhenDataChanges(params({\n      currentIndex: 2,\n      direction: \"negative\",\n      previousLength: 4,\n      currentLength: 3,\n    }));\n\n    expect(handlerOffset / size).toBe(1 * negative);\n  });\n\n  it(\"The direction is positive, Changing length of data set from 4 to 5, the index remains original.\", async () => {\n    const handlerOffset = computeNewIndexWhenDataChanges(params({\n      currentIndex: 3,\n      direction: \"positive\",\n      previousLength: 4,\n      currentLength: 5,\n    }));\n\n    expect(handlerOffset / size).toBe(3 * positive);\n  });\n\n  it(\"The direction is negative, Changing length of data set from 4 to 5, the index remains original.\", async () => {\n    const handlerOffset = computeNewIndexWhenDataChanges(params({\n      currentIndex: 3,\n      direction: \"negative\",\n      previousLength: 4,\n      currentLength: 5,\n    }));\n\n    expect(handlerOffset / size).toBe(4 * negative);\n  });\n\n  it(\"Changing length of data set from 0 to 3, the index remains original.\", async () => {\n    const handlerOffset = computeNewIndexWhenDataChanges(params({\n      currentIndex: 0,\n      direction: \"positive\",\n      previousLength: 0,\n      currentLength: 3,\n    }));\n\n    expect(handlerOffset / size).toBe(0 * positive);\n  });\n});\n"]}